/**
 * Функция is_date проверяет является ли параметр date датой записанной в
 * "правильном" формате. Возвращает True, если формат верный, иначе - возвращает False.
 * Регулярное выражение  должно соответсовать
 * дате следующих форматов (д - день, м - месяц, г - год):
 *
 *         дд.мм.гггг
 *         дд-мм-гггг
 *         дд/мм/гггг
 *
 * @param str - строковое представление даты
 * @returns true если дата соответсвует формату, false - в противном случае
 */
function is_date(str) {
    return /\d{1,2}([.\-\/])\d{1,2}\1\d{1,4}/.test(str);
}

/**
 * Функция is_phone проверяет является ли параметр phone телефоном записанным в
 * "правильном" формате. Возвращает True, если формат верный, иначе - возвращает False.
 *  Регулярное выражение должно соответсовать телефону следующих форматов (ц - цифра в диапазоне от 0 до 9):
 *
 *       ццц-цц-цц
 *      (0цц) ццц-цц-цц
 *      +38 (0цц) ццц-цц-цц
 *
 * @param str - строковое представление телефона
 * @returns true если str соответсвует формату телефона, false - в противном случае
 */
function is_phone(str) {
    // (\+\d{2} )?(\(0\d{2}\) )?\d{3}\-\d{2}\-\d{2} -- второй вариант регулярки если нужно код в формате отличном от +38
    return /(\+38 )?(\(0\d{2}\) )?\d{3}\-\d{2}\-\d{2}/.test(str);
}

/**
 * Функция is_dummy_match используя регулярное выражение проверяет является ли параметр text значением из
 * первой колонки. В этом случае возвращается значение True, a значение False -
 * если значения из второй колонки:
 *
 *  pit
 *  spot            pt
 *  spate            Pot
 *  slap two        peat
 *  respite            part
 *
 * @param str
 * @returns {undefined}
 */
function is_dummy_match(str) {
    // мой первый вариант, проходит тесты
    // if (str === '') {
    //     return false;
    // }
    //
    // let re = /(\bpit)?(\bspot)?(\bspate)?(\bslap two)?(\brespite)?()?(\bpt)?(\bPot)?(\bpeat)?(\bpart)?/g;
    // let m = re.exec(str);
    // let flagTrue = false;
    // let flagFalse = false;
    // for (let i = 1; i < m.length; i++) {
    //     if (i < 6) {
    //         if(m[i] != undefined) {
    //             flagTrue = true;
    //             break;
    //         }
    //     } else {
    //         if(m[i] != undefined) {
    //             flagFalse = true;
    //             break;
    //         }
    //     }
    // }
    //
    // if (flagTrue) {
    //     return true;
    // }
    // if (flagFalse) {
    //     return false;
    // }
    // return 'error';

    // второй вариант
    return /[psr][ipl]/.test(str);
}

/**
 * Функция parse_tag принимает параметр html - строку текста и возвращает имя тега
 * и содержимое элемента в виде массива.
 *
 * Открывающий тег в html заключаестя в угловые скобки (< и >), а закрывающий
 * - в < и />. Содержимое элемента помещается между открывающим и закрывающим
 * тегом. Пример:
 *
 * <title>Заголовок</title>
 *
 * Тегом является слово title, а содержимое элемента - Заголовок.
 * Для извлечения данных необходимо написать регулярное выражение, в котором
 * выделить первую группу - имя тега, а во вторую - поместить содержимое.
 * Если тег не имеет содержимого, то функция должна возвратить массив из
 * одного элемента - имени тега
 * @param str
 * @returns массив, первый элемент - имя тега, второй - содержимое (если есть)
 */
function parse_tag(str) {
    let m = /<([a-zA-Z0-9]+)[^>\/]*?(?:\/>|>([^<]*)<\/\1>)/.exec(str);
    let array = new Array();
    if (m === null) {
        return array;
    }
    if (m[1] != undefined) {
        array.push(m[1]);
        if (m[2] != undefined) {
            array.push(m[2]);
        }
    }
    console.log(array);
    console.log();
    return array;
}
